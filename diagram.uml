@startuml
left to right direction

package ru.spbau.mit.aush {

    package lexer {

        together {

            enum WordPartType {
                PLAIN_QUOTED
                RAW_QUOTED
                UNQUOTED
            }

            WordPart *-- WordPartType

            class WordPart {
                +string: String
                +type: WordPartType
            }

            Word *-- WordPart

            class Word {
                +parts: List<WordPart>
            }

            LCommand *-- Word

            class LCommand {
                +words: List<Word>
            }

        }

        together {

            abstract class LexerException {
                +message: String
            }

            LexerException <|- LexerInternalException

            class LexerInternalException {
                +message: String
            }

            LexerException <|- NoCommandBeforePipeException

            object NoCommandBeforePipeException {
                +message: String = "missing command before pipe"
            }

            LexerException <|- NoCommandAfterPipeException

            object NoCommandAfterPipeException {
                +message: String = "missing command after pipe"
            }

            LexerException <|- UnclosedQuoteException

            class UnclosedQuoteException {
                +quote: Char
                +message: String = "missing pair to a '$quote'-quote"
            }

        }

        together {

            abstract class LexResult {

            }

            LexResult <|- LexSuccess

            class LexSuccess {
                +commands: List<LCommand>
            }

            LexResult <|-- LexFailure

            class LexFailure {
                +cause: LexerException
            }

        }

        Word <|-[hidden]- Lexer

        class Lexer {
            -text: String
            
            {method} -lex(): List<LCommand>
        }

        Lexer <-> LexerCompanion

        object LexerCompanion {
            -PLAIN_QUOTE: Char = '\"'
            -RAW_QUOTE: Char = '\''
            -PIPE: Char = '|'
            -WS: String = "\\s\\n"

            {method} +tryLex(text: String): LexResult 
        }
    }

    package parser {
        abstract class Parser<F, T> {
            +abstract parse(input: F): T
        }

        Parser <|- EnvironmentVariableParser

        object EnvironmentVariableParser {
            +parse(input: Word): Pair<String,Word>?
        }

        Parser <|- CommandParser

        object CommandParser {
            +parse(input: LCommand): ASTNode
        }

        Parser <|- CommandListParser
        object CommandListParser {
            +parse(input: List<LCommand>): ASTNode
        }
    }

    package ast {
        abstract class ASTNode {
            {abstract} +evaluate(environment: Environment): EvaluationResult
        }

        ASTNode <|- CommandNode

        class CommandNode {
            -commandName: Word
            -args: List<Word>
            +evaluate(environment: Environment): EvaluationResult
        }

        ASTNode <|- PipeNode

        class PipeNode {
            -left: ASTNode
            -right: ASTNode
            +evaluate(environment: Environment): EvaluationResult
        }

        ASTNode <|- DefineVariableNode

        class DefineVariableNode {
            -name: String
            -value: Word
            -followingNode: ASTNode
            +evaluate(environment: Environment): EvaluationResult
        }

        ASTNode <|- EmptyNode

        object EmptyNode {
            {method} +evaluate(environment: Environment): EvaluationResult
        }
    }

    package evaluation {

        together {

            abstract class EvaluationResult

            EvaluationResult <|- EvaluationSuccess

            class EvaluationSuccess {
                +modifiedEnvironmentVariables: EnvironmentVariables
            }

            EvaluationResult <|- SuccessfullyExited

            object SuccessfullyExited {

            }

            EvaluationResult <|- EvaluationFailure

            class EvaluationFailure {
                +command: String
                +cause: Throwable
            }

        }

        together {

            abstract class EvaluationException {
                +message: String? = null
                +cause: Throwable? = null
            }

            EvaluationException <-[hidden]- EvaluationResult

            EvaluationException <|- CommandEvaluationFailedException

            class CommandEvaluationFailedException {
                +command: String
                +cause: Throwable
            }

        }

        together {

            abstract class Command {
                abstract +evaluate(args: List<String>, environment: Environment)
            }

            Command <-> CommandCompanion

            object CommandCompanion {
                {method} +getCommand(name: String): Command
                -commands: Map<String,Command>
            }

            Command <|-- CatCommand

            object CatCommand {
                +evaluate(args: List<String>, environment: Environment)
            }

            Command <|-- EchoCommand

            object EchoCommand {
                +evaluate(args: List<String>, environment: Environment)
            }

            Command <|-- WcCommand

            object WcCommand {
                +evaluate(args: List<String>, environment: Environment)
            }

            Command <|-- PwdCommand

            object PwdCommand {
                +evaluate(args: List<String>, environment: Environment)
            }

            Command <|-- ExitCommand

            object ExitCommand {
                +evaluate(args: List<String>, environment: Environment)
            }

            Command <|-- ExternalCommand

            class ExternalCommand {
                +evaluate(args: List<String>, environment: Environment)
                +name: String
            }

        }

        together {

            class EnvironmentVariables {
                +data: Map<String, String>
            }

            class EnvironmentIO {
                +input: InputStream
                +output: OutputStream
                +error: OutputStream
            }

            Environment *-- EnvironmentVariables
            Environment *-- EnvironmentIO

            class Environment {
                +variables: EnvironmentVariables
                +io: EnvironmentIO
            }

        }

    }

    class Repl {
        -environmentIO: EnvironmentIO
        -environmentVariables: EnvironmentVariables

        +run()

        -greet()
        -runInner()
        -promptInput()
        -readCommand(): ASTNode?

    }

}

@enduml